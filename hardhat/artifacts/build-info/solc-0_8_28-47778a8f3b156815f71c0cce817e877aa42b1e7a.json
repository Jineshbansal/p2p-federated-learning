{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-47778a8f3b156815f71c0cce817e877aa42b1e7a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/fed-learn.sol": "project/contracts/fed-learn.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/fed-learn.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n\n/// @title Federated Training Reward Contract\n/// @notice Create a training task by providing IPFS hashes for model & dataset, number of chunks, and depositing reward funds.\n/// Trainers publish final weights (IPFS hash) and receive reward = totalDeposit / numChunks per accepted submission.\ncontract FederatedTrainingReward {\nuint256 public taskCount;\n\n\nstruct Task {\naddress payable depositor;\nstring modelHash; // IPFS hash of model\nstring datasetHash; // IPFS hash of dataset\nuint256 numChunks; // total number of chunks\nuint256 remainingChunks; // how many chunk-rewards remain\nuint256 perChunkReward; // wei per chunk\nbool exists;\n}\n\n// taskId => Task\nmapping(uint256 => Task) public tasks;\n// taskId => trainer address => hasSubmitted\nmapping(uint256 => mapping(address => bool)) public hasSubmitted;\n// pending withdrawals for trainers if transfers fail or for refunds\nmapping(address => uint256) public pendingWithdrawals;\n\n\n/// @dev emitted when a task is created\nevent TaskCreated(\nuint256 indexed taskId,\naddress indexed depositor,\nstring modelHash,\nstring datasetHash,\nuint256 numChunks,\nuint256 totalReward\n);\n\n\n/// @dev emitted when a trainer publishes weights and receives reward (or credited)\nevent WeightsSubmitted(\nuint256 indexed taskId,\naddress indexed trainer,\nstring weightsHash,\nuint256 rewardAmount,\nuint256 remainingChunks\n);\n\n\n/// @dev emitted when someone withdraws pending balance\nevent Withdrawn(address indexed who, uint256 amount);\n\n\n/// @notice Create a new training task and deposit reward funds.\n/// @param modelHash IPFS hash of the model (string)\n/// @param datasetHash IPFS hash of the dataset (string)\n/// @param numChunks Number of chunks the dataset is divided into (must be > 0)\n/// Requirements: msg.value must be > 0 and divisible by numChunks to ensure exact per-chunk reward.\nfunction createTask(\nstring calldata modelHash,\nstring calldata datasetHash,\nuint256 numChunks\n) external payable returns (uint256) {\nrequire(numChunks > 0, \"numChunks must be > 0\");\nrequire(msg.value > 0, \"deposit required\");\nrequire(msg.value % numChunks == 0, \"deposit must be divisible by numChunks\");\n\n\ntaskCount += 1;\nuint256 taskId = taskCount;\n\n\nuint256 perChunk = msg.value / numChunks;\n\n\ntasks[taskId] = Task({\ndepositor: payable(msg.sender),\nmodelHash: modelHash,\ndatasetHash: datasetHash,\nnumChunks: numChunks,\nremainingChunks: numChunks,\nperChunkReward: perChunk,\nexists: true\n});\n\n\nemit TaskCreated(taskId, msg.sender, modelHash, datasetHash, numChunks, msg.value);\nreturn taskId;\n}\n\n/// @notice Trainer submits final weights (IPFS hash) for a task and claims the per-chunk reward.\n/// Each address can only submit once per task. Rewards are paid out immediately if the transfer succeeds,\n/// otherwise credited to pendingWithdrawals which can be withdrawn with withdrawPending().\n/// @param taskId The id of the task\n/// @param weightsHash IPFS hash of the published weights\nfunction submitWeights(uint256 taskId, string calldata weightsHash) external {\nTask storage t = tasks[taskId];\nrequire(t.exists, \"task does not exist\");\nrequire(t.remainingChunks > 0, \"no rewards remaining for this task\");\nrequire(!hasSubmitted[taskId][msg.sender], \"already submitted for this task\");\n\n\n// mark as submitted first to avoid reentrancy issues\nhasSubmitted[taskId][msg.sender] = true;\nt.remainingChunks -= 1;\n\n\nuint256 reward = t.perChunkReward;\n\n\n// attempt to send reward; if it fails, credit pendingWithdrawals\n(bool sent, ) = payable(msg.sender).call{value: reward}('');\nif (!sent) {\n// credit so trainer can withdraw later\npendingWithdrawals[msg.sender] += reward;\n}\n\n\nemit WeightsSubmitted(taskId, msg.sender, weightsHash, reward, t.remainingChunks);\n}\n\n\n/// @notice Withdraw any pending balance credited to the caller (e.g., failed transfers)\nfunction withdrawPending() external {\nuint256 amount = pendingWithdrawals[msg.sender];\nrequire(amount > 0, \"no pending balance\");\npendingWithdrawals[msg.sender] = 0;\n\n\n(bool sent, ) = payable(msg.sender).call{value: amount}('');\nrequire(sent, \"withdraw transfer failed\");\n\n\nemit Withdrawn(msg.sender, amount);\n}\n\n\n/// @notice Cancel a task and refund remaining funds to depositor.\n/// Only allowed if no submissions have happened (i.e., remainingChunks == numChunks).\n/// This protects trainers' expectations once submissions begin.\n/// @param taskId id of the task to cancel\nfunction cancelTask(uint256 taskId) external {\nTask storage t = tasks[taskId];\nrequire(t.exists, \"task does not exist\");\nrequire(msg.sender == t.depositor, \"only depositor can cancel\");\nrequire(t.remainingChunks == t.numChunks, \"cannot cancel after submissions started\");\n\n\nuint256 refund = t.perChunkReward * t.remainingChunks;\n// delete task to free storage\ndelete tasks[taskId];\n\n\n(bool sent, ) = t.depositor.call{value: refund}('');\nrequire(sent, \"refund transfer failed\");\n}\n\n\n/// @notice Allow contract to accept ETH deposits (not used directly by this contract logic)\nreceive() external payable {}\n\nfunction setPendingWithdrawal(address _address, uint256 _amount) public {\n    pendingWithdrawals[_address] = _amount;\n}\n\n\n\n\nfallback() external payable {}\n}"
      }
    }
  }
}